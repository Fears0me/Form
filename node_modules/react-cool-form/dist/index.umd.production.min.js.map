{"version":3,"file":"index.umd.production.min.js","sources":["../node_modules/dequal/lite/index.mjs","../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isFileList.ts","../src/utils/isObject.ts","../src/utils/cloneObject.ts","../src/utils/compact.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/get.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/utils/set.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/useForm.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts","../src/utils/runWithLowPriority.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (arr: any[]): Map =>\n  arr.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","import isFileList from \"./isFileList\";\nimport isObject from \"./isObject\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  if (isObject(object))\n    return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n      obj[key] = cloneObject((object as Record<string, any>)[key]);\n      return obj;\n    }, {});\n\n  throw new Error(\"Unable to clone object.\");\n};\n\nexport default cloneObject;\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","export default (value: unknown): value is undefined => value === undefined;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Record<string, any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Record<string, any>)[key],\n      (touched as Record<string, any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return isUndefined(value) ? defaultValue : value;\n};\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Record<string, never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = stringToPath(path);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(Number(segs[idx + 1]));\n    if (isPlainObject(obj[key]) && !nextIsNumber) return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","/* eslint-disable no-prototype-builtins */\n\nimport cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isObject from \"./isObject\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (isObject(target) && target.hasOwnProperty(last)) delete target[last];\n\n  return refObject;\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Map,\n  SetStateRef,\n  SetUsedStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const usedStateRef = useRef<Map>({});\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n\n        path = fieldPath || path;\n\n        if (\n          shouldUpdate &&\n          (Object.keys(usedStateRef.current).some(\n            (k) => path.startsWith(k) || k.startsWith(path)\n          ) ||\n            (usedStateRef.current.isDirty && isDirty !== prevIsDirty) ||\n            (usedStateRef.current.isValid && isValid !== prevIsValid))\n        ) {\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedStateRef = useCallback<SetUsedStateRef>(\n    (path, unset = false) => {\n      if (unset) {\n        delete usedStateRef.current[path];\n      } else {\n        usedStateRef.current[path] = true;\n      }\n    },\n    []\n  );\n\n  return { stateRef, setStateRef, setUsedStateRef };\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst getIsDirty = (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isPlainObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n\nexport default getIsDirty;\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  ClearErrors,\n  Config,\n  Controller,\n  FieldArgs,\n  FieldElement,\n  Fields,\n  FieldValidator,\n  FieldsValue,\n  FormErrors,\n  FormState,\n  FormValues,\n  GetState,\n  Handlers,\n  Map,\n  RegisterField,\n  RegisterForm,\n  Reset,\n  Return,\n  RunValidation,\n  SetDirty,\n  SetError,\n  SetTouched,\n  SetValue,\n  Submit,\n} from \"./types\";\nimport { useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isMultipleSelect,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  builtInValidationMode = \"message\",\n  shouldRemoveField = true,\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: Config<V> = {}): Return<V> => {\n  const isInitRef = useRef(true);\n  const handlersRef = useRef<Handlers>({});\n  const observerRef = useRef<MutationObserver>();\n  const formRef = useRef<HTMLFormElement>();\n  const fieldsRef = useRef<Fields>({});\n  const fieldArgsRef = useRef<FieldArgs>({});\n  const controllersRef = useRef<Map>({});\n  const excludeFieldsRef = useRef<Map>(arrayToMap(excludeFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Record<string, FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, setUsedStateRef } = useState<V>(\n    initialStateRef.current,\n    debug\n  );\n\n  const getFields = useCallback(\n    (form: HTMLFormElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            dataset: { rcfExclude },\n          } = field;\n\n          if (/button|image|submit|reset/.test(type)) return false;\n          if (rcfExclude && !name) {\n            warn('ðŸ’¡ react-cool-form > field: Missing the \"name\" attribute.');\n            return false;\n          }\n\n          return (\n            controllersRef.current[name] ||\n            !(rcfExclude || excludeFieldsRef.current[name])\n          );\n        })\n        .reduce((acc: Record<string, any>, cur) => {\n          const field = cur as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: cur };\n\n          if (isCheckboxInput(field) || isRadioInput(field))\n            acc[name].options = acc[name].options\n              ? [...acc[name].options, cur]\n              : [cur];\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const handleUnset = useCallback(\n    (path: string, fieldPath: string, target: any, name: string) =>\n      setStateRef(path, unset(target, name, true), { fieldPath }),\n    [setStateRef]\n  );\n\n  const getNodeValue = useCallback(\n    (name: string) => {\n      const { field, options } = fieldsRef.current[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldArgsRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldArgsRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        if (options) {\n          const checkboxes = options as HTMLInputElement[];\n\n          if (options.length > 1) {\n            value = checkboxes\n              .filter((checkbox) => checkbox.checked)\n              .map((checkbox) => checkbox.value);\n          } else {\n            value = checkboxes[0].checked;\n          }\n        } else {\n          let checkValues = get(stateRef.current.values, field.name);\n\n          if (Array.isArray(checkValues)) {\n            checkValues = new Set(checkValues);\n\n            if (field.checked) {\n              checkValues.add(value);\n            } else {\n              checkValues.delete(value);\n            }\n\n            value = Array.from(checkValues);\n          } else {\n            value = field.checked;\n          }\n        }\n      }\n\n      if (isRadioInput(field) && options)\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isMultipleSelect(field) && !options)\n        value = Array.from(field.options)\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    [stateRef]\n  );\n\n  const setNodeValue = useCallback((name: string, value: any) => {\n    if (!fieldsRef.current[name] || controllersRef.current[name]) return;\n\n    const { field, options } = fieldsRef.current[name];\n\n    if (isCheckboxInput(field)) {\n      const checkboxes = options as HTMLInputElement[];\n\n      if (checkboxes.length > 1) {\n        checkboxes.forEach((checkbox) => {\n          checkbox.checked = Array.isArray(value)\n            ? value.includes(checkbox.value)\n            : !!value;\n        });\n      } else {\n        checkboxes[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      (options as HTMLInputElement[]).forEach((radio) => {\n        radio.checked = radio.value === value;\n      });\n    } else if (isMultipleSelect(field) && Array.isArray(value)) {\n      Array.from(field.options).forEach((option) => {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value ?? \"\";\n    }\n  }, []);\n\n  const setDefaultValue = useCallback(\n    (name: string, value: any) => {\n      if (!isUndefined(get(initialStateRef.current.values, name))) return;\n\n      initialStateRef.current.values = set(\n        initialStateRef.current.values,\n        name,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, get(initialStateRef.current.values, name), {\n        shouldUpdate: !isInitRef.current,\n      });\n    },\n    [setStateRef]\n  );\n\n  const setNodesOrStateValue = useCallback(\n    (\n      values: V,\n      checkDefaultValues = false,\n      fields: FieldsValue[] | string[] = Object.values(fieldsRef.current)\n    ) =>\n      fields.forEach((field: FieldsValue | string) => {\n        const name = isPlainObject(field)\n          ? (field as FieldsValue).field.name\n          : field;\n\n        if (controllersRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (checkDefaultValues) {\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(defaultValue) ? defaultValue : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, { target, watch = true, errorWithTouched = false } = {}) => {\n      if (!path) return undefined;\n\n      const getPath = (p: string) => {\n        if (p === \"values\" && !target && watch)\n          warn(\n            'ðŸ’¡ react-cool-form > getState: Get the \"values\" alone may cause unnecessary re-renders. If you know what you\\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices'\n          );\n\n        p = target ? `${target}.${p}` : p;\n\n        if (watch) setUsedStateRef(p);\n\n        return p;\n      };\n      const errorsEnhancer = (p: string, state: any) => {\n        if (\n          !watch ||\n          !errorWithTouched ||\n          !p.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        p = p.replace(\"errors\", \"touched\");\n        setUsedStateRef(p);\n\n        return filterErrors(state, get(stateRef.current, p));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((p) => {\n          p = getPath(p);\n          return errorsEnhancer(p, get(stateRef.current, p));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Record<string, string>;\n        state = Object.keys(paths).reduce((s: Record<string, any>, key) => {\n          path = getPath(paths[key]);\n          s[key] = errorsEnhancer(path, get(stateRef.current, path));\n          return s;\n        }, {});\n      } else {\n        path = getPath(path);\n        state = errorsEnhancer(path, get(stateRef.current, path));\n      }\n\n      return state;\n    },\n    [setUsedStateRef, stateRef]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) =>\n          handleUnset(\"errors\", `errors.${n}`, stateRef.current.errors, n)\n        );\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current[name])\n        return undefined;\n\n      const { field } = fieldsRef.current[name];\n\n      if (builtInValidationMode === \"message\") return field.validationMessage;\n\n      for (const k in field.validity) {\n        // @ts-expect-error\n        if (k !== \"valid\" && field.validity[k]) return k;\n      }\n\n      return undefined;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Object.keys(fieldsRef.current).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name) => {\n      if (!name) return validateForm().then((errors) => isEmptyObject(errors));\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then(\n          (errors) => !compact(errors).length\n        );\n\n      return validateField(name).then((error) => !error);\n    },\n    [validateField, validateForm]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, shouldValidate = validateOnBlur) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(\n          \"touched\",\n          `touched.${name}`,\n          stateRef.current.touched,\n          name\n        );\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setStateRef,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnBlur,\n    ]\n  );\n\n  const setTouchedMaybeValidate = useCallback(\n    (name: string) =>\n      setTouched(\n        name,\n        true,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        get(stateRef.current.values, name) !==\n          get(initialStateRef.current.values, name)\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(\"values\", `values.${name}`, stateRef.current.values, name);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setTouched(name, true, false);\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      formState: stateRef.current,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      reset,\n      submit,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current.values = nextValues;\n          setNodesOrStateValue(initialStateRef.current.values, !!values);\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const nextTouched = Object.keys({\n        ...fieldsRef.current,\n        ...controllersRef.current,\n      }).reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]\n  );\n\n  const handleChangeEvent = useCallback(\n    (name: string, value: any) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const controller = useCallback<Controller<V>>(\n    (\n      name,\n      {\n        validate: validator,\n        value,\n        defaultValue,\n        parse,\n        format,\n        onChange,\n        onBlur,\n      } = {}\n    ) => {\n      if (!name) {\n        warn('ðŸ’¡ react-cool-form > controller: Missing the \"name\" parameter.');\n        return undefined;\n      }\n\n      controllersRef.current[name] = true;\n      if (validator) fieldValidatorsRef.current[name] = validator;\n\n      const val = get(defaultValuesRef.current, name);\n      defaultValue = !isUndefined(val) ? val : defaultValue;\n      if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);\n\n      value = !isUndefined(value) ? value : getState(`values.${name}`);\n      value = (format ? format(value) : value) ?? \"\";\n\n      return {\n        name,\n        value,\n        onChange: (...args) => {\n          let v;\n\n          if (parse) {\n            v = parse(...args);\n          } else {\n            const e = args[0];\n            v =\n              e?.nativeEvent instanceof Event && isFieldElement(e.target)\n                ? getNodeValue(name)\n                : e;\n          }\n\n          handleChangeEvent(name, v);\n          if (onChange) onChange(...args, v);\n          changedFieldRef.current = name;\n        },\n        onBlur: (e) => {\n          setTouchedMaybeValidate(name);\n          if (onBlur) onBlur(e);\n          changedFieldRef.current = undefined;\n        },\n      };\n    },\n    [\n      getNodeValue,\n      getState,\n      handleChangeEvent,\n      setDefaultValue,\n      setTouchedMaybeValidate,\n    ]\n  );\n\n  const registerForm = useCallback<RegisterForm>(\n    (el) => {\n      if (!el) return;\n\n      formRef.current = el;\n      const form = formRef.current;\n\n      fieldsRef.current = getFields(form);\n      setNodesOrStateValue(initialStateRef.current.values, true);\n      isInitRef.current = false;\n\n      handlersRef.current.change = ({ target }: Event) => {\n        const { name } = target as FieldElement;\n\n        if (!name) {\n          warn('ðŸ’¡ react-cool-form > field: Missing the \"name\" attribute.');\n          return;\n        }\n\n        if (fieldsRef.current[name] && !controllersRef.current[name]) {\n          const parse = fieldArgsRef.current[name]?.parse;\n          const value = getNodeValue(name);\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          changedFieldRef.current = name;\n        }\n      };\n\n      handlersRef.current.blur = ({ target }: Event) => {\n        if (!isFieldElement(target as HTMLElement)) return;\n\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current[name] && !controllersRef.current[name]) {\n          setTouchedMaybeValidate(name);\n          changedFieldRef.current = undefined;\n        }\n      };\n\n      handlersRef.current.submit = (e: Event) => submit(e as any);\n\n      handlersRef.current.reset = (e: Event) => reset(null, null, e as any);\n\n      form.addEventListener(\"input\", handlersRef.current.change);\n      form.addEventListener(\"focusout\", handlersRef.current.blur);\n      form.addEventListener(\"submit\", handlersRef.current.submit);\n      form.addEventListener(\"reset\", handlersRef.current.reset);\n\n      observerRef.current = new MutationObserver(([{ type }]) => {\n        if (type !== \"childList\") return;\n\n        const fields = getFields(form);\n        let { values } = stateRef.current;\n\n        if (shouldRemoveField)\n          Object.keys(fieldsRef.current).forEach((name) => {\n            if (fields[name]) return;\n\n            handleUnset(\n              \"values\",\n              `values.${name}`,\n              stateRef.current.values,\n              name\n            );\n            handleUnset(\n              \"touched\",\n              `touched.${name}`,\n              stateRef.current.touched,\n              name\n            );\n            handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n            handleUnset(\n              \"errors\",\n              `errors.${name}`,\n              stateRef.current.errors,\n              name\n            );\n            setUsedStateRef(name, true);\n\n            initialStateRef.current.values = unset(\n              initialStateRef.current.values,\n              name,\n              true\n            );\n            delete fieldArgsRef.current[name];\n            delete fieldValidatorsRef.current[name];\n            delete controllersRef.current[name];\n          });\n\n        const addedNodes: string[] = [];\n\n        Object.keys(fields).forEach((name) => {\n          if (fieldsRef.current[name] || controllersRef.current[name]) return;\n\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          if (!isUndefined(defaultValue))\n            values = set(values, name, defaultValue, true);\n\n          addedNodes.push(name);\n        });\n\n        fieldsRef.current = fields;\n        if (addedNodes.length) setNodesOrStateValue(values, true, addedNodes);\n      });\n\n      observerRef.current.observe(form, { childList: true, subtree: true });\n    },\n    [\n      getFields,\n      getNodeValue,\n      handleChangeEvent,\n      handleUnset,\n      reset,\n      setNodesOrStateValue,\n      setTouchedMaybeValidate,\n      setUsedStateRef,\n      shouldRemoveField,\n      stateRef,\n      submit,\n    ]\n  );\n\n  const registerField = useCallback<RegisterField<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controllersRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = validateOrOptions;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldArgsRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  useEffect(\n    () => () => {\n      if (!formRef.current) return;\n\n      const hanlders = handlersRef.current as Required<Handlers>;\n\n      formRef.current.removeEventListener(\"input\", hanlders.change);\n      formRef.current.removeEventListener(\"focusout\", hanlders.blur);\n      formRef.current.removeEventListener(\"submit\", hanlders.submit);\n      formRef.current.removeEventListener(\"reset\", hanlders.reset);\n      observerRef.current?.disconnect();\n    },\n    []\n  );\n\n  return {\n    form: registerForm,\n    field: registerField,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n    controller,\n  };\n};\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: /* istanbul ignore next */ () =>\n              Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n"],"names":["has","Object","prototype","hasOwnProperty","dequal","foo","bar","ctor","len","constructor","Date","getTime","RegExp","toString","Array","length","call","keys","val","ref","useRef","useEffect","current","arr","reduce","obj","key","value","FileList","cloneObject","object","Event","Error","isObject","isFileList","isArray","map","filter","Boolean","deepMerge","objects","prev","forEach","prevValue","currValue","isPlainObject","undefined","filterErrors","error","touched","nextErrors","isUndefined","str","TypeError","compact","split","path","defaultValue","stringToPath","isFunction","name","field","type","element","test","tagName","immutable","segs","newObject","slice","idx","nextIsNumber","Number","isNaN","refObject","last","pop","target","initialState","onChange","forceUpdate","useReducer","c","stateRef","usedStateRef","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","get","state","set","errors","dirty","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","dty","found","values","push","getIsDirty","isEmptyObject","some","k","startsWith","setUsedStateRef","unset","defaultValues","validate","validateOnChange","validateOnBlur","builtInValidationMode","shouldRemoveField","excludeFields","onReset","onSubmit","onError","debug","isInitRef","handlersRef","observerRef","formRef","fieldsRef","fieldArgsRef","controllersRef","excludeFieldsRef","arrayToMap","changedFieldRef","formValidatorRef","fieldValidatorsRef","onResetRef","onSubmitRef","onErrorRef","defaultValuesRef","initialStateRef","isValidating","isSubmitting","isSubmitted","useState","getFields","form","from","querySelectorAll","rcfExclude","dataset","acc","cur","isCheckboxInput","isRadioInput","options","handleUnset","getNodeValue","_fieldArgsRef$current","valueAsNumber","_fieldArgsRef$current2","valueAsDate","isNumberInput","isRangeInput","checkboxes","checkbox","checked","checkValues","Set","add","find","radio","isMultipleSelect","option","selected","isFileInput","files","setNodeValue","includes","setDefaultValue","setNodesOrStateValue","checkDefaultValues","fields","getState","watch","errorWithTouched","getPath","p","errorsEnhancer","replace","paths","s","setError","clearErrors","n","runBuiltInValidation","validationMessage","validity","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","all","then","runFormValidation","validateField","hasAsyncValidator","isAsyncFunction","validateFieldWithLowPriority","callback","window","requestIdleCallback","cb","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","validateForm","errs","runValidation","setTouched","isTouched","shouldValidate","setTouchedMaybeValidate","setDirty","setDirtyIfNeeded","setValue","shouldTouched","shouldDirty","getOptions","formState","reset","submit","exclude","e","preventDefault","stopPropagation","skip","nextValues","nextTouched","handleChangeEvent","controller","validator","parse","format","onBlur","v","args","nativeEvent","isFieldElement","registerForm","el","change","_fieldArgsRef$current3","blur","addEventListener","MutationObserver","addedNodes","observe","childList","subtree","registerField","validateOrOptions","parsers","hanlders","removeEventListener","disconnect"],"mappings":"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"}