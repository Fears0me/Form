{"version":3,"file":"index.cjs.production.min.js","sources":["../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isFileList.ts","../src/utils/isObject.ts","../src/utils/cloneObject.ts","../src/utils/compact.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/get.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/utils/set.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/useForm.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts","../src/utils/runWithLowPriority.ts"],"sourcesContent":["import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (arr: any[]): Map =>\n  arr.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","import isFileList from \"./isFileList\";\nimport isObject from \"./isObject\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  if (isObject(object))\n    return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n      obj[key] = cloneObject((object as Record<string, any>)[key]);\n      return obj;\n    }, {});\n\n  throw new Error(\"Unable to clone object.\");\n};\n\nexport default cloneObject;\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","export default (value: unknown): value is undefined => value === undefined;\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Record<string, any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Record<string, any>)[key],\n      (touched as Record<string, any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return isUndefined(value) ? defaultValue : value;\n};\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Record<string, never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = stringToPath(path);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(Number(segs[idx + 1]));\n    if (isPlainObject(obj[key]) && !nextIsNumber) return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","/* eslint-disable no-prototype-builtins */\n\nimport cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isObject from \"./isObject\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (isObject(target) && target.hasOwnProperty(last)) delete target[last];\n\n  return refObject;\n};\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Map,\n  SetStateRef,\n  SetUsedStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const usedStateRef = useRef<Map>({});\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n\n        path = fieldPath || path;\n\n        if (\n          shouldUpdate &&\n          (Object.keys(usedStateRef.current).some(\n            (k) => path.startsWith(k) || k.startsWith(path)\n          ) ||\n            (usedStateRef.current.isDirty && isDirty !== prevIsDirty) ||\n            (usedStateRef.current.isValid && isValid !== prevIsValid))\n        ) {\n          forceUpdate();\n          onChangeRef.current(stateRef.current);\n        }\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedStateRef = useCallback<SetUsedStateRef>(\n    (path, unset = false) => {\n      if (unset) {\n        delete usedStateRef.current[path];\n      } else {\n        usedStateRef.current[path] = true;\n      }\n    },\n    []\n  );\n\n  return { stateRef, setStateRef, setUsedStateRef };\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst getIsDirty = (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isPlainObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n\nexport default getIsDirty;\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  ClearErrors,\n  Config,\n  Controller,\n  FieldArgs,\n  FieldElement,\n  Fields,\n  FieldValidator,\n  FieldsValue,\n  FormErrors,\n  FormState,\n  FormValues,\n  GetState,\n  Handlers,\n  Map,\n  RegisterField,\n  RegisterForm,\n  Reset,\n  Return,\n  RunValidation,\n  SetDirty,\n  SetError,\n  SetTouched,\n  SetValue,\n  Submit,\n} from \"./types\";\nimport { useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isMultipleSelect,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  builtInValidationMode = \"message\",\n  shouldRemoveField = true,\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: Config<V> = {}): Return<V> => {\n  const isInitRef = useRef(true);\n  const handlersRef = useRef<Handlers>({});\n  const observerRef = useRef<MutationObserver>();\n  const formRef = useRef<HTMLFormElement>();\n  const fieldsRef = useRef<Fields>({});\n  const fieldArgsRef = useRef<FieldArgs>({});\n  const controllersRef = useRef<Map>({});\n  const excludeFieldsRef = useRef<Map>(arrayToMap(excludeFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Record<string, FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, setUsedStateRef } = useState<V>(\n    initialStateRef.current,\n    debug\n  );\n\n  const getFields = useCallback(\n    (form: HTMLFormElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            dataset: { rcfExclude },\n          } = field;\n\n          if (/button|image|submit|reset/.test(type)) return false;\n          if (rcfExclude && !name) {\n            warn('💡 react-cool-form > field: Missing the \"name\" attribute.');\n            return false;\n          }\n\n          return (\n            controllersRef.current[name] ||\n            !(rcfExclude || excludeFieldsRef.current[name])\n          );\n        })\n        .reduce((acc: Record<string, any>, cur) => {\n          const field = cur as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: cur };\n\n          if (isCheckboxInput(field) || isRadioInput(field))\n            acc[name].options = acc[name].options\n              ? [...acc[name].options, cur]\n              : [cur];\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const handleUnset = useCallback(\n    (path: string, fieldPath: string, target: any, name: string) =>\n      setStateRef(path, unset(target, name, true), { fieldPath }),\n    [setStateRef]\n  );\n\n  const getNodeValue = useCallback(\n    (name: string) => {\n      const { field, options } = fieldsRef.current[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldArgsRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldArgsRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        if (options) {\n          const checkboxes = options as HTMLInputElement[];\n\n          if (options.length > 1) {\n            value = checkboxes\n              .filter((checkbox) => checkbox.checked)\n              .map((checkbox) => checkbox.value);\n          } else {\n            value = checkboxes[0].checked;\n          }\n        } else {\n          let checkValues = get(stateRef.current.values, field.name);\n\n          if (Array.isArray(checkValues)) {\n            checkValues = new Set(checkValues);\n\n            if (field.checked) {\n              checkValues.add(value);\n            } else {\n              checkValues.delete(value);\n            }\n\n            value = Array.from(checkValues);\n          } else {\n            value = field.checked;\n          }\n        }\n      }\n\n      if (isRadioInput(field) && options)\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isMultipleSelect(field) && !options)\n        value = Array.from(field.options)\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    [stateRef]\n  );\n\n  const setNodeValue = useCallback((name: string, value: any) => {\n    if (!fieldsRef.current[name] || controllersRef.current[name]) return;\n\n    const { field, options } = fieldsRef.current[name];\n\n    if (isCheckboxInput(field)) {\n      const checkboxes = options as HTMLInputElement[];\n\n      if (checkboxes.length > 1) {\n        checkboxes.forEach((checkbox) => {\n          checkbox.checked = Array.isArray(value)\n            ? value.includes(checkbox.value)\n            : !!value;\n        });\n      } else {\n        checkboxes[0].checked = !!value;\n      }\n    } else if (isRadioInput(field)) {\n      (options as HTMLInputElement[]).forEach((radio) => {\n        radio.checked = radio.value === value;\n      });\n    } else if (isMultipleSelect(field) && Array.isArray(value)) {\n      Array.from(field.options).forEach((option) => {\n        option.selected = !!value.includes(option.value);\n      });\n    } else if (isFileInput(field)) {\n      if (isFileList(value)) field.files = value;\n      if (!value) field.value = \"\";\n    } else {\n      field.value = value ?? \"\";\n    }\n  }, []);\n\n  const setDefaultValue = useCallback(\n    (name: string, value: any) => {\n      if (!isUndefined(get(initialStateRef.current.values, name))) return;\n\n      initialStateRef.current.values = set(\n        initialStateRef.current.values,\n        name,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, get(initialStateRef.current.values, name), {\n        shouldUpdate: !isInitRef.current,\n      });\n    },\n    [setStateRef]\n  );\n\n  const setNodesOrStateValue = useCallback(\n    (\n      values: V,\n      checkDefaultValues = false,\n      fields: FieldsValue[] | string[] = Object.values(fieldsRef.current)\n    ) =>\n      fields.forEach((field: FieldsValue | string) => {\n        const name = isPlainObject(field)\n          ? (field as FieldsValue).field.name\n          : field;\n\n        if (controllersRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (checkDefaultValues) {\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(defaultValue) ? defaultValue : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, { target, watch = true, errorWithTouched = false } = {}) => {\n      if (!path) return undefined;\n\n      const getPath = (p: string) => {\n        if (p === \"values\" && !target && watch)\n          warn(\n            '💡 react-cool-form > getState: Get the \"values\" alone may cause unnecessary re-renders. If you know what you\\'re doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices'\n          );\n\n        p = target ? `${target}.${p}` : p;\n\n        if (watch) setUsedStateRef(p);\n\n        return p;\n      };\n      const errorsEnhancer = (p: string, state: any) => {\n        if (\n          !watch ||\n          !errorWithTouched ||\n          !p.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        p = p.replace(\"errors\", \"touched\");\n        setUsedStateRef(p);\n\n        return filterErrors(state, get(stateRef.current, p));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((p) => {\n          p = getPath(p);\n          return errorsEnhancer(p, get(stateRef.current, p));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Record<string, string>;\n        state = Object.keys(paths).reduce((s: Record<string, any>, key) => {\n          path = getPath(paths[key]);\n          s[key] = errorsEnhancer(path, get(stateRef.current, path));\n          return s;\n        }, {});\n      } else {\n        path = getPath(path);\n        state = errorsEnhancer(path, get(stateRef.current, path));\n      }\n\n      return state;\n    },\n    [setUsedStateRef, stateRef]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) =>\n          handleUnset(\"errors\", `errors.${n}`, stateRef.current.errors, n)\n        );\n      } else {\n        handleUnset(\"errors\", `errors.${name}`, stateRef.current.errors, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current[name])\n        return undefined;\n\n      const { field } = fieldsRef.current[name];\n\n      if (builtInValidationMode === \"message\") return field.validationMessage;\n\n      for (const k in field.validity) {\n        // @ts-expect-error\n        if (k !== \"valid\" && field.validity[k]) return k;\n      }\n\n      return undefined;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Object.keys(fieldsRef.current).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`💡 react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`💡 react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name) => {\n      if (!name) return validateForm().then((errors) => isEmptyObject(errors));\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then(\n          (errors) => !compact(errors).length\n        );\n\n      return validateField(name).then((error) => !error);\n    },\n    [validateField, validateForm]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, shouldValidate = validateOnBlur) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(\n          \"touched\",\n          `touched.${name}`,\n          stateRef.current.touched,\n          name\n        );\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setStateRef,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnBlur,\n    ]\n  );\n\n  const setTouchedMaybeValidate = useCallback(\n    (name: string) =>\n      setTouched(\n        name,\n        true,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        get(stateRef.current.values, name) !==\n          get(initialStateRef.current.values, name)\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(\"values\", `values.${name}`, stateRef.current.values, name);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setTouched(name, true, false);\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      formState: stateRef.current,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      reset,\n      submit,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current.values = nextValues;\n          setNodesOrStateValue(initialStateRef.current.values, !!values);\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      e?.preventDefault();\n      e?.stopPropagation();\n\n      const nextTouched = Object.keys({\n        ...fieldsRef.current,\n        ...controllersRef.current,\n      }).reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`💡 react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]\n  );\n\n  const handleChangeEvent = useCallback(\n    (name: string, value: any) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const controller = useCallback<Controller<V>>(\n    (\n      name,\n      {\n        validate: validator,\n        value,\n        defaultValue,\n        parse,\n        format,\n        onChange,\n        onBlur,\n      } = {}\n    ) => {\n      if (!name) {\n        warn('💡 react-cool-form > controller: Missing the \"name\" parameter.');\n        return undefined;\n      }\n\n      controllersRef.current[name] = true;\n      if (validator) fieldValidatorsRef.current[name] = validator;\n\n      const val = get(defaultValuesRef.current, name);\n      defaultValue = !isUndefined(val) ? val : defaultValue;\n      if (!isUndefined(defaultValue)) setDefaultValue(name, defaultValue);\n\n      value = !isUndefined(value) ? value : getState(`values.${name}`);\n      value = (format ? format(value) : value) ?? \"\";\n\n      return {\n        name,\n        value,\n        onChange: (...args) => {\n          let v;\n\n          if (parse) {\n            v = parse(...args);\n          } else {\n            const e = args[0];\n            v =\n              e?.nativeEvent instanceof Event && isFieldElement(e.target)\n                ? getNodeValue(name)\n                : e;\n          }\n\n          handleChangeEvent(name, v);\n          if (onChange) onChange(...args, v);\n          changedFieldRef.current = name;\n        },\n        onBlur: (e) => {\n          setTouchedMaybeValidate(name);\n          if (onBlur) onBlur(e);\n          changedFieldRef.current = undefined;\n        },\n      };\n    },\n    [\n      getNodeValue,\n      getState,\n      handleChangeEvent,\n      setDefaultValue,\n      setTouchedMaybeValidate,\n    ]\n  );\n\n  const registerForm = useCallback<RegisterForm>(\n    (el) => {\n      if (!el) return;\n\n      formRef.current = el;\n      const form = formRef.current;\n\n      fieldsRef.current = getFields(form);\n      setNodesOrStateValue(initialStateRef.current.values, true);\n      isInitRef.current = false;\n\n      handlersRef.current.change = ({ target }: Event) => {\n        const { name } = target as FieldElement;\n\n        if (!name) {\n          warn('💡 react-cool-form > field: Missing the \"name\" attribute.');\n          return;\n        }\n\n        if (fieldsRef.current[name] && !controllersRef.current[name]) {\n          const parse = fieldArgsRef.current[name]?.parse;\n          const value = getNodeValue(name);\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          changedFieldRef.current = name;\n        }\n      };\n\n      handlersRef.current.blur = ({ target }: Event) => {\n        if (!isFieldElement(target as HTMLElement)) return;\n\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current[name] && !controllersRef.current[name]) {\n          setTouchedMaybeValidate(name);\n          changedFieldRef.current = undefined;\n        }\n      };\n\n      handlersRef.current.submit = (e: Event) => submit(e as any);\n\n      handlersRef.current.reset = (e: Event) => reset(null, null, e as any);\n\n      form.addEventListener(\"input\", handlersRef.current.change);\n      form.addEventListener(\"focusout\", handlersRef.current.blur);\n      form.addEventListener(\"submit\", handlersRef.current.submit);\n      form.addEventListener(\"reset\", handlersRef.current.reset);\n\n      observerRef.current = new MutationObserver(([{ type }]) => {\n        if (type !== \"childList\") return;\n\n        const fields = getFields(form);\n        let { values } = stateRef.current;\n\n        if (shouldRemoveField)\n          Object.keys(fieldsRef.current).forEach((name) => {\n            if (fields[name]) return;\n\n            handleUnset(\n              \"values\",\n              `values.${name}`,\n              stateRef.current.values,\n              name\n            );\n            handleUnset(\n              \"touched\",\n              `touched.${name}`,\n              stateRef.current.touched,\n              name\n            );\n            handleUnset(\"dirty\", `dirty.${name}`, stateRef.current.dirty, name);\n            handleUnset(\n              \"errors\",\n              `errors.${name}`,\n              stateRef.current.errors,\n              name\n            );\n            setUsedStateRef(name, true);\n\n            initialStateRef.current.values = unset(\n              initialStateRef.current.values,\n              name,\n              true\n            );\n            delete fieldArgsRef.current[name];\n            delete fieldValidatorsRef.current[name];\n            delete controllersRef.current[name];\n          });\n\n        const addedNodes: string[] = [];\n\n        Object.keys(fields).forEach((name) => {\n          if (fieldsRef.current[name] || controllersRef.current[name]) return;\n\n          const defaultValue = get(defaultValuesRef.current, name);\n\n          if (!isUndefined(defaultValue))\n            values = set(values, name, defaultValue, true);\n\n          addedNodes.push(name);\n        });\n\n        fieldsRef.current = fields;\n        if (addedNodes.length) setNodesOrStateValue(values, true, addedNodes);\n      });\n\n      observerRef.current.observe(form, { childList: true, subtree: true });\n    },\n    [\n      getFields,\n      getNodeValue,\n      handleChangeEvent,\n      handleUnset,\n      reset,\n      setNodesOrStateValue,\n      setTouchedMaybeValidate,\n      setUsedStateRef,\n      shouldRemoveField,\n      stateRef,\n      submit,\n    ]\n  );\n\n  const registerField = useCallback<RegisterField<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controllersRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = validateOrOptions;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldArgsRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  useEffect(\n    () => () => {\n      if (!formRef.current) return;\n\n      const hanlders = handlersRef.current as Required<Handlers>;\n\n      formRef.current.removeEventListener(\"input\", hanlders.change);\n      formRef.current.removeEventListener(\"focusout\", hanlders.blur);\n      formRef.current.removeEventListener(\"submit\", hanlders.submit);\n      formRef.current.removeEventListener(\"reset\", hanlders.reset);\n      observerRef.current?.disconnect();\n    },\n    []\n  );\n\n  return {\n    form: registerForm,\n    field: registerField,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n    controller,\n  };\n};\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: /* istanbul ignore next */ () =>\n              Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n"],"names":["val","ref","useRef","useEffect","current","arr","reduce","obj","key","value","FileList","cloneObject","object","Event","Error","isObject","isFileList","Date","getTime","Array","isArray","map","Object","keys","filter","Boolean","deepMerge","objects","prev","forEach","prevValue","currValue","isPlainObject","undefined","filterErrors","error","touched","nextErrors","isUndefined","str","TypeError","length","compact","split","path","defaultValue","stringToPath","isFunction","constructor","name","field","type","element","test","tagName","immutable","segs","newObject","slice","idx","nextIsNumber","Number","isNaN","refObject","hasOwnProperty","last","pop","target","initialState","onChange","forceUpdate","useReducer","c","stateRef","usedStateRef","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","dequal","get","state","set","errors","dirty","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","dty","found","values","push","getIsDirty","isEmptyObject","some","k","startsWith","setUsedStateRef","unset","defaultValues","validate","validateOnChange","validateOnBlur","builtInValidationMode","shouldRemoveField","excludeFields","onReset","onSubmit","onError","debug","isInitRef","handlersRef","observerRef","formRef","fieldsRef","fieldArgsRef","controllersRef","excludeFieldsRef","arrayToMap","changedFieldRef","formValidatorRef","fieldValidatorsRef","onResetRef","onSubmitRef","onErrorRef","defaultValuesRef","initialStateRef","isValidating","isSubmitting","isSubmitted","useState","getFields","form","from","querySelectorAll","rcfExclude","dataset","acc","cur","isCheckboxInput","isRadioInput","options","handleUnset","getNodeValue","_fieldArgsRef$current","valueAsNumber","_fieldArgsRef$current2","valueAsDate","isNumberInput","isRangeInput","checkboxes","checkbox","checked","checkValues","Set","add","find","radio","isMultipleSelect","option","selected","isFileInput","files","setNodeValue","includes","setDefaultValue","setNodesOrStateValue","checkDefaultValues","fields","getState","watch","errorWithTouched","getPath","p","errorsEnhancer","replace","paths","s","setError","clearErrors","n","runBuiltInValidation","validationMessage","validity","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","all","then","runFormValidation","validateField","hasAsyncValidator","isAsyncFunction","validateFieldWithLowPriority","callback","window","requestIdleCallback","cb","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","validateForm","errs","runValidation","setTouched","isTouched","shouldValidate","setTouchedMaybeValidate","setDirty","setDirtyIfNeeded","setValue","shouldTouched","shouldDirty","getOptions","formState","reset","submit","exclude","e","preventDefault","stopPropagation","skip","nextValues","nextTouched","handleChangeEvent","controller","validator","parse","format","onBlur","v","args","nativeEvent","isFieldElement","registerForm","el","change","_fieldArgsRef$current3","blur","addEventListener","MutationObserver","addedNodes","observe","childList","subtree","registerField","validateOrOptions","parsers","hanlders","removeEventListener","disconnect"],"mappings":"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"}